import os
import json
import time
import random
from dataclasses import dataclass
from typing import List, Dict, Any, Tuple, Optional

from openai import OpenAI
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Lock

import re
import math

# --- 環境変数の設定 ---
MODEL = "gpt-4o-mini"
SEED = 42
MAX_RETRIES = 10
MAX_WORKERS = 15

TRAIN_PATH = "train/math_level12_easy_train100_student_with_answer_solution.jsonl"

# CV settings
N_SPLITS = 5
PROMPT_TRAIN_K = 40
TEMPERATURE = 0.0

print_lock = Lock() # マルチスレッド用のロック


# --- IO ---
# JSONL を読む関数
def read_jsonl(path: str) -> List[Dict[str, Any]]:
    data = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line:
                data.append(json.loads(line))
    return data


# --- Evaluation utils ---
import re
import math
from typing import Optional, Tuple

_NUM_RE = re.compile(r"[-+]?\d+(?:\.\d+)?(?:[eE][-+]?\d+)?")

def normalize_answer(s: str) -> str:
    """
    表記ゆれをかなり潰す（数学用）。
    目的: 文字列完全一致の事故を減らす。
    """
    if s is None:
        return ""
    s = str(s).strip()

    # "FINAL:" プレフィックス除去
    if s.upper().startswith("FINAL:"):
        s = s.split(":", 1)[1].strip()

    # よくある余計な装飾の除去
    s = s.strip()
    s = s.replace("−", "-")  # U+2212 を ASCII '-' に
    s = s.replace("–", "-").replace("—", "-")
    s = s.replace(",", "")   # 2,000 -> 2000

    # LaTeXっぽい \frac{a}{b} を a/b に寄せる（簡易）
    s = re.sub(r"\\frac\{([^{}]+)\}\{([^{}]+)\}", r"\1/\2", s)

    # 両端の括弧などを剥がす（(2) -> 2, [2] -> 2）
    s = s.strip()
    s = re.sub(r"^[\(\[\{]\s*", "", s)
    s = re.sub(r"\s*[\)\]\}]$", "", s)

    # 空白を詰める（" 1 / 2 " -> "1/2"）
    s = re.sub(r"\s+", "", s)

    return s


def try_parse_number(s: str) -> Optional[float]:
    """
    文字列を「数値」として解釈できるなら float を返す。
    - 整数/小数/指数表記
    - a/b 形式（分数）
    """
    if not s:
        return None

    # 分数
    if "/" in s and s.count("/") == 1:
        a, b = s.split("/")
        if a and b:
            na = try_parse_number(a)
            nb = try_parse_number(b)
            if na is not None and nb is not None and nb != 0:
                return na / nb
        return None

    # 純粋な数値（±, 小数, 指数）
    if re.fullmatch(r"[-+]?\d+(?:\.\d+)?(?:[eE][-+]?\d+)?", s):
        try:
            return float(s)
        except:
            return None

    return None


def accuracy(rows, preds, *, rel_tol=1e-9, abs_tol=1e-9) -> float:
    """
    1) normalize した文字列が一致 → 正解
    2) それでも違うなら、数値として解釈できる場合は数値比較（許容誤差つき）
    """
    gold_by_id = {int(r["id"]): r["answer"] for r in rows}

    correct = 0
    total = 0

    for p in preds:
        qid = int(p["id"])
        pred_raw = p.get("prediction", "")
        gold_raw = gold_by_id.get(qid, "")

        pred = normalize_answer(pred_raw)
        gold = normalize_answer(gold_raw)

        total += 1

        if pred == gold:
            correct += 1
            continue

        # 数値比較（両方数値にできるなら）
        pn = try_parse_number(pred)
        gn = try_parse_number(gold)
        if pn is not None and gn is not None:
            if math.isclose(pn, gn, rel_tol=rel_tol, abs_tol=abs_tol):
                correct += 1
                continue

    return correct / total if total else 0.0



# --- K-fold split (independent) ---
# K-fold 分割 を行う関数
def kfold_split(rows: List[Dict[str, Any]], n_splits: int, seed: int) -> List[Tuple[List[int], List[int]]]:
    """
    rows の index を n_splits に分割し、
    (train_indices, val_indices) を fold ごとに返す。
    """
    rng = random.Random(seed)
    idx = list(range(len(rows)))
    rng.shuffle(idx)

    folds: List[List[int]] = [[] for _ in range(n_splits)]
    for i, j in enumerate(idx):
        folds[i % n_splits].append(j)

    out: List[Tuple[List[int], List[int]]] = []
    all_idx_set = set(idx)
    for f in range(n_splits):
        val_idx = folds[f]
        train_idx = list(all_idx_set - set(val_idx))
        out.append((train_idx, val_idx))
    return out

# 先頭 k 個を取る汎用関数
def take_k(rows: List[Dict[str, Any]], k: int, seed: int) -> List[Dict[str, Any]]:
    rng = random.Random(seed)
    tmp = rows[:]
    rng.shuffle(tmp)
    return tmp[: min(k, len(tmp))]


# --- OpenAI call (structured output) ---
# OpenAI API 呼び出しを行う関数
def call_model_json(
    client: OpenAI,
    model: str,
    instructions: str,                   
    input_messages: List[Dict[str, str]],  
    temperature: float = 0.0,
    max_retries: int = 10,
) -> Dict[str, Any]:

    schema = {
        "type": "json_schema",
        "name": "math_prediction",
        "strict": True,
        "schema": {
            "type": "object",
            "properties": {
                "id": {"type": "integer"},
                "prediction": {"type": "string"},
            },
            "required": ["id", "prediction"],
            "additionalProperties": False,
        },
    }

    for attempt in range(max_retries):
        try:
            resp = client.responses.create(
                model=model,
                instructions=instructions, 
                input=input_messages,             
                text={"format": schema},         
                temperature=temperature,
                store=False,
            )
            return json.loads(resp.output_text)
        except Exception as e:
            if attempt == max_retries - 1:
                raise
            sleep_s = 2 ** attempt
            with print_lock:
                print(f"[warn] {e} -> retry in {sleep_s}s")
            time.sleep(sleep_s)

    raise RuntimeError("unreachable")



# --- PromptModel (independent) ---
# few-shot の作り方を定義している
@dataclass
class PromptModel:
    """
    「訓練データの一部」から、推論に使う messages（system + fewshot）を構築する
    """
    fewshot_k: int
    seed: int

    def build_prompt(self, prompt_train_rows):
        instructions = (
            "あなたは数学問題を解くアシスタントです。"
            "必要なら頭の中で途中計算してよいが、出力は必ず次のJSONのみ: "
            '{"id": <int>, "prediction": "FINAL: <答え>"}'
            "predictionには答え以外を入れない。"
        )

        fewshot_msgs = []
        for ex in prompt_train_rows:
            ex_id = int(ex["id"])
            problem = str(ex.get("problem", "")).strip()
            answer = str(ex.get("answer", "")).strip()

            user_content = (
                "次の数学問題を解いて。\n\n"
                f"problem:\n{problem}\n\n"
                f"id は {ex_id}。\n"
                "JSONで出力して。prediction は 'FINAL: <答え>' だけ。"
            )
            fewshot_msgs.append({"role": "user", "content": user_content})
            fewshot_msgs.append({
                "role": "assistant",
                "content": json.dumps({"id": ex_id, "prediction": f"FINAL: {answer}"}, ensure_ascii=False),
            })

        return instructions, fewshot_msgs



# --- Inference on a dataset given a prompt ---
# 問題を解くための関数
def solve_one(client, model, instructions, fewshot_msgs, row):
    qid = row["id"]
    problem = row["problem"]

    user_msg = {
        "role": "user",
        "content": (
            f"problem:\n{problem}\n\n"
            f"id は {qid}。\n"
            "JSONで出力して。prediction は 'FINAL: <答え>' だけ。"
        ),
    }

    input_messages = []
    if fewshot_msgs:
        input_messages += fewshot_msgs
    input_messages += [user_msg]

    pred_obj = call_model_json(
        client=client,
        model=model,
        instructions=instructions,    
        input_messages=input_messages,
        temperature=TEMPERATURE,
        max_retries=MAX_RETRIES,
    )

    pred_obj["id"] = qid
    p = str(pred_obj.get("prediction", "")).strip()
    if not p.startswith("FINAL:"):
        p = "FINAL: " + p
    pred_obj["prediction"] = p
    return pred_obj

# データセットを解くための関数 (並列化、スレッド数は MAX_WORKERS で指定)
def run_inference(
    client: OpenAI,
    model: str,
    system_msg: Dict[str, str],
    fewshot_msgs: List[Dict[str, str]],
    rows: List[Dict[str, Any]],
    desc: str = "",
) -> List[Dict[str, Any]]:
    outputs: List[Dict[str, Any]] = []
    done = 0
    total = len(rows)

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
        futures = [
            ex.submit(solve_one, client, model, system_msg, fewshot_msgs, row)
            for row in rows
        ]
        for fut in as_completed(futures):
            pred = fut.result()
            outputs.append(pred)
            done += 1
            if done % 10 == 0:
                with print_lock:
                    print(f"{desc} done {done}/{total}")

    outputs.sort(key=lambda x: x["id"])
    return outputs

# --- Cross-validation runner ---
# 交差検証の本体部分
def cross_validate_prompt_model(
    client: OpenAI,
    model: str,
    rows: List[Dict[str, Any]],
    prompt_model: PromptModel,
    n_splits: int,
    seed: int,
) -> Dict[str, Any]:
    splits = kfold_split(rows, n_splits=n_splits, seed=seed)

    fold_scores: List[float] = []
    for fold_i, (train_idx, val_idx) in enumerate(splits, start=1):
        train_rows = [rows[i] for i in train_idx]
        val_rows = [rows[i] for i in val_idx]

        # プロンプトの構築
        prompt_train_rows = take_k(train_rows, prompt_model.fewshot_k, seed + fold_i)
        instructions, fewshot_msgs = prompt_model.build_prompt(prompt_train_rows)

        # 精度の測定
        preds = run_inference(
            client, model, instructions, fewshot_msgs, val_rows, desc=f"[fold {fold_i}/{n_splits}]"
        )
        fold_acc = accuracy(val_rows, preds)
        fold_scores.append(fold_acc)

        with print_lock:
            print(f"[fold {fold_i}] acc = {fold_acc:.4f} (val={len(val_rows)})")

    mean_acc = sum(fold_scores) / len(fold_scores) if fold_scores else 0.0
    return {
        "model": model,
        "n_splits": n_splits,
        "fewshot_k": prompt_model.fewshot_k,
        "fold_scores": fold_scores,
        "mean_score": mean_acc,
    }


# --- main ---
def main():
    if not os.getenv("OPENAI_API_KEY"):
        raise RuntimeError("OPENAI_API_KEY が環境変数に設定されていません。")

    client = OpenAI()
    rows = read_jsonl(TRAIN_PATH)

    prompt_model = PromptModel(
        fewshot_k=PROMPT_TRAIN_K,
        seed=SEED,
    )

    result = cross_validate_prompt_model(
        client=client,
        model=MODEL,
        rows=rows,
        prompt_model=prompt_model,
        n_splits=N_SPLITS,
        seed=SEED,
    )

    print("\n=== CV RESULT ===")
    print(json.dumps(result, ensure_ascii=False, indent=2))


if __name__ == "__main__":
    main()
